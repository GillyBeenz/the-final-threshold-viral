"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/utils/tracking.ts":
/*!*******************************!*\
  !*** ./lib/utils/tracking.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractTrackingParams: function() { return /* binding */ extractTrackingParams; },\n/* harmony export */   getClientIP: function() { return /* binding */ getClientIP; },\n/* harmony export */   getDeviceType: function() { return /* binding */ getDeviceType; },\n/* harmony export */   hashIP: function() { return /* binding */ hashIP; },\n/* harmony export */   trackClick: function() { return /* binding */ trackClick; },\n/* harmony export */   trackConversion: function() { return /* binding */ trackConversion; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase/client */ \"(app-pages-browser)/./lib/supabase/client.ts\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ua-parser-js */ \"(app-pages-browser)/./node_modules/ua-parser-js/src/ua-parser.js\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ua_parser_js__WEBPACK_IMPORTED_MODULE_1__);\n// Click Tracking and Analytics Utilities\n\n\n/**\r\n * Get device type from user agent\r\n */ function getDeviceType(userAgent) {\n    const parser = new (ua_parser_js__WEBPACK_IMPORTED_MODULE_1___default())(userAgent);\n    const deviceType = parser.getDevice().type;\n    if (deviceType === \"mobile\") return \"mobile\";\n    if (deviceType === \"tablet\") return \"tablet\";\n    return \"desktop\";\n}\n/**\r\n * Hash IP address for privacy (client-side hashing)\r\n */ async function hashIP(ip) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(ip + \"salt_secret_key\");\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map((b)=>b.toString(16).padStart(2, \"0\")).join(\"\");\n}\n/**\r\n * Track a click event\r\n */ async function trackClick(params) {\n    try {\n        const deviceType = getDeviceType(params.userAgent);\n        const ipHash = params.ipAddress ? await hashIP(params.ipAddress) : null;\n        // Get referral ID if code provided\n        let referralId = null;\n        if (params.referralCode) {\n            const { data } = await _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"referrals\").select(\"id\").eq(\"referral_code\", params.referralCode).single();\n            referralId = (data === null || data === void 0 ? void 0 : data.id) || null;\n        }\n        var _params_landingPage;\n        const { data, error } = await _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"clicks\").insert({\n            referral_id: referralId,\n            utm_source: params.utmSource,\n            utm_medium: params.utmMedium,\n            utm_campaign: params.utmCampaign,\n            device_type: deviceType,\n            ip_hash: ipHash,\n            landing_page: (_params_landingPage = params.landingPage) !== null && _params_landingPage !== void 0 ? _params_landingPage : true,\n            converted: false\n        }).select(\"id\").single();\n        if (error) throw error;\n        return {\n            clickId: data === null || data === void 0 ? void 0 : data.id,\n            error: null\n        };\n    } catch (err) {\n        console.error(\"Error tracking click:\", err);\n        return {\n            clickId: null,\n            error: err\n        };\n    }\n}\n/**\r\n * Track a conversion (Amazon CTA click)\r\n */ async function trackConversion(params) {\n    try {\n        // Get referral ID if code provided\n        let referralId = null;\n        if (params.referralCode) {\n            const { data } = await _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"referrals\").select(\"id\").eq(\"referral_code\", params.referralCode).single();\n            referralId = (data === null || data === void 0 ? void 0 : data.id) || null;\n        }\n        // Insert conversion\n        const { error: conversionError } = await _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"conversions\").insert({\n            click_id: params.clickId,\n            referral_id: referralId,\n            amazon_url: params.amazonUrl\n        });\n        if (conversionError) throw conversionError;\n        // Update click as converted if clickId provided\n        if (params.clickId) {\n            await _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"clicks\").update({\n                converted: true\n            }).eq(\"id\", params.clickId);\n        }\n        return {\n            success: true,\n            error: null\n        };\n    } catch (err) {\n        console.error(\"Error tracking conversion:\", err);\n        return {\n            success: false,\n            error: err\n        };\n    }\n}\n/**\r\n * Get client IP address (server-side only)\r\n */ function getClientIP(request) {\n    var _headers_get;\n    // Try various headers (Vercel, Cloudflare, etc.)\n    const headers = request.headers;\n    return headers.get(\"x-real-ip\") || ((_headers_get = headers.get(\"x-forwarded-for\")) === null || _headers_get === void 0 ? void 0 : _headers_get.split(\",\")[0]) || headers.get(\"cf-connecting-ip\") || null;\n}\n/**\r\n * Extract tracking parameters from URL\r\n */ function extractTrackingParams(url) {\n    const urlObj = new URL(url);\n    const params = urlObj.searchParams;\n    return {\n        referralCode: params.get(\"ref\") || undefined,\n        utmSource: params.get(\"utm_source\") || undefined,\n        utmMedium: params.get(\"utm_medium\") || undefined,\n        utmCampaign: params.get(\"utm_campaign\") || undefined\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi91dGlscy90cmFja2luZy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBeUM7QUFFTztBQUNiO0FBR25DOztDQUVDLEdBQ00sU0FBU0UsY0FBY0MsU0FBaUI7SUFDN0MsTUFBTUMsU0FBUyxJQUFJSCxxREFBUUEsQ0FBQ0U7SUFDNUIsTUFBTUUsYUFBYUQsT0FBT0UsU0FBUyxHQUFHQyxJQUFJO0lBRTFDLElBQUlGLGVBQWUsVUFBVSxPQUFPO0lBQ3BDLElBQUlBLGVBQWUsVUFBVSxPQUFPO0lBQ3BDLE9BQU87QUFDVDtBQUVBOztDQUVDLEdBQ00sZUFBZUcsT0FBT0MsRUFBVTtJQUNyQyxNQUFNQyxVQUFVLElBQUlDO0lBQ3BCLE1BQU1DLE9BQU9GLFFBQVFHLE1BQU0sQ0FBQ0osS0FBSztJQUNqQyxNQUFNSyxhQUFhLE1BQU1DLE9BQU9DLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLFdBQVdMO0lBQ3pELE1BQU1NLFlBQVlDLE1BQU1DLElBQUksQ0FBQyxJQUFJQyxXQUFXUDtJQUM1QyxPQUFPSSxVQUFVSSxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRyxNQUFNQyxJQUFJLENBQUM7QUFDbEU7QUFFQTs7Q0FFQyxHQUNNLGVBQWVDLFdBQVdDLE1BUWhDO0lBQ0MsSUFBSTtRQUNGLE1BQU12QixhQUFhSCxjQUFjMEIsT0FBT3pCLFNBQVM7UUFDakQsTUFBTTBCLFNBQVNELE9BQU9FLFNBQVMsR0FBRyxNQUFNdEIsT0FBT29CLE9BQU9FLFNBQVMsSUFBSTtRQUVuRSxtQ0FBbUM7UUFDbkMsSUFBSUMsYUFBNEI7UUFDaEMsSUFBSUgsT0FBT0ksWUFBWSxFQUFFO1lBQ3ZCLE1BQU0sRUFBRXBCLElBQUksRUFBRSxHQUFHLE1BQU1aLDBEQUFRQSxDQUM1Qm9CLElBQUksQ0FBQyxhQUNMYSxNQUFNLENBQUMsTUFDUEMsRUFBRSxDQUFDLGlCQUFpQk4s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QUFDLGlCQUFpQk87UUFDdkMxQixhQUFhakIsT0FBT29DLEdBQUcsQ0FBQyxtQkFBbUJPO0lBQzdDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3V0aWxzL3RyYWNraW5nLnRzPzcxMjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2xpY2sgVHJhY2tpbmcgYW5kIEFuYWx5dGljcyBVdGlsaXRpZXNcclxuXHJcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UvY2xpZW50J1xyXG5pbXBvcnQgVUFQYXJzZXIgZnJvbSAndWEtcGFyc2VyLWpzJ1xyXG5pbXBvcnQgdHlwZSB7IERldmljZVR5cGUsIENsaWNrRXZlbnQsIENvbnZlcnNpb25FdmVudCB9IGZyb20gJ0AvdHlwZXMnXHJcblxyXG4vKipcclxuICogR2V0IGRldmljZSB0eXBlIGZyb20gdXNlciBhZ2VudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERldmljZVR5cGUodXNlckFnZW50OiBzdHJpbmcpOiBEZXZpY2VUeXBlIHtcclxuICBjb25zdCBwYXJzZXIgPSBuZXcgVUFQYXJzZXIodXNlckFnZW50KVxyXG4gIGNvbnN0IGRldmljZVR5cGUgPSBwYXJzZXIuZ2V0RGV2aWNlKCkudHlwZVxyXG4gIFxyXG4gIGlmIChkZXZpY2VUeXBlID09PSAnbW9iaWxlJykgcmV0dXJuICdtb2JpbGUnXHJcbiAgaWYgKGRldmljZVR5cGUgPT09ICd0YWJsZXQnKSByZXR1cm4gJ3RhYmxldCdcclxuICByZXR1cm4gJ2Rlc2t0b3AnXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYXNoIElQIGFkZHJlc3MgZm9yIHByaXZhY3kgKGNsaWVudC1zaWRlIGhhc2hpbmcpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFzaElQKGlwOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxyXG4gIGNvbnN0IGRhdGEgPSBlbmNvZGVyLmVuY29kZShpcCArICdzYWx0X3NlY3JldF9rZXknKVxyXG4gIGNvbnN0IGhhc2hCdWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGRhdGEpXHJcbiAgY29uc3QgaGFzaEFycmF5ID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShoYXNoQnVmZmVyKSlcclxuICByZXR1cm4gaGFzaEFycmF5Lm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFjayBhIGNsaWNrIGV2ZW50XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJhY2tDbGljayhwYXJhbXM6IHtcclxuICByZWZlcnJhbENvZGU/OiBzdHJpbmdcclxuICB1dG1Tb3VyY2U/OiBzdHJpbmdcclxuICB1dG1NZWRpdW0/OiBzdHJpbmdcclxuICB1dG1DYW1wYWlnbj86IHN0cmluZ1xyXG4gIHVzZXJBZ2VudDogc3RyaW5nXHJcbiAgaXBBZGRyZXNzPzogc3RyaW5nXHJcbiAgbGFuZGluZ1BhZ2U/OiBib29sZWFuXHJcbn0pOiBQcm9taXNlPHsgY2xpY2tJZDogc3RyaW5nIHwgbnVsbDsgZXJyb3I6IEVycm9yIHwgbnVsbCB9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGRldmljZVR5cGUgPSBnZXREZXZpY2VUeXBlKHBhcmFtcy51c2VyQWdlbnQpXHJcbiAgICBjb25zdCBpcEhhc2ggPSBwYXJhbXMuaXBBZGRyZXNzID8gYXdhaXQgaGFzaElQKHBhcmFtcy5pcEFkZHJlc3MpIDogbnVsbFxyXG4gICAgXHJcbiAgICAvLyBHZXQgcmVmZXJyYWwgSUQgaWYgY29kZSBwcm92aWRlZFxyXG4gICAgbGV0IHJlZmVycmFsSWQ6IHN0cmluZyB8IG51bGwgPSBudWxsXHJcbiAgICBpZiAocGFyYW1zLnJlZmVycmFsQ29kZSkge1xyXG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3JlZmVycmFscycpXHJcbiAgICAgICAgLnNlbGVjdCgnaWQnKVxyXG4gICAgICAgIC5lcSgncmVmZXJyYWxfY29kZScsIHBhcmFtcy5yZWZlcnJhbENvZGUpXHJcbiAgICAgICAgLnNpbmdsZSgpXHJcbiAgICAgIFxyXG4gICAgICByZWZlcnJhbElkID0gKGRhdGEgYXMgYW55KT8uaWQgfHwgbnVsbFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnY2xpY2tzJylcclxuICAgICAgLmluc2VydCh7XHJcbiAgICAgICAgcmVmZXJyYWxfaWQ6IHJlZmVycmFsSWQsXHJcbiAgICAgICAgdXRtX3NvdXJjZTogcGFyYW1zLnV0bVNvdXJjZSxcclxuICAgICAgICB1dG1fbWVkaXVtOiBwYXJhbXMudXRtTWVkaXVtLFxyXG4gICAgICAgIHV0bV9jYW1wYWlnbjogcGFyYW1zLnV0bUNhbXBhaWduLFxyXG4gICAgICAgIGRldmljZV90eXBlOiBkZXZpY2VUeXBlLFxyXG4gICAgICAgIGlwX2hhc2g6IGlwSGFzaCxcclxuICAgICAgICBsYW5kaW5nX3BhZ2U6IHBhcmFtcy5sYW5kaW5nUGFnZSA/PyB0cnVlLFxyXG4gICAgICAgIGNvbnZlcnRlZDogZmFsc2UsXHJcbiAgICAgIH0gYXMgYW55KVxyXG4gICAgICAuc2VsZWN0KCdpZCcpXHJcbiAgICAgIC5zaW5nbGUoKVxyXG4gICAgXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgICBcclxuICAgIHJldHVybiB7IGNsaWNrSWQ6IChkYXRhIGFzIGFueSk/LmlkIGFzIHN0cmluZyB8IG51bGwsIGVycm9yOiBudWxsIH1cclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHRyYWNraW5nIGNsaWNrOicsIGVycilcclxuICAgIHJldHVybiB7IGNsaWNrSWQ6IG51bGwsIGVycm9yOiBlcnIgYXMgRXJyb3IgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYWNrIGEgY29udmVyc2lvbiAoQW1hem9uIENUQSBjbGljaylcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cmFja0NvbnZlcnNpb24ocGFyYW1zOiB7XHJcbiAgY2xpY2tJZD86IHN0cmluZ1xyXG4gIHJlZmVycmFsQ29kZT86IHN0cmluZ1xyXG4gIGFtYXpvblVybDogc3RyaW5nXHJcbn0pOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I6IEVycm9yIHwgbnVsbCB9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIEdldCByZWZlcnJhbCBJRCBpZiBjb2RlIHByb3ZpZGVkXHJcbiAgICBsZXQgcmVmZXJyYWxJZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcclxuICAgIGlmIChwYXJhbXMucmVmZXJyYWxDb2RlKSB7XHJcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgncmVmZXJyYWxzJylcclxuICAgICAgICAuc2VsZWN0KCdpZCcpXHJcbiAgICAgICAgLmVxKCdyZWZlcnJhbF9jb2RlJywgcGFyYW1zLnJlZmVycmFsQ29kZSlcclxuICAgICAgICAuc2luZ2xlKClcclxuICAgICAgXHJcbiAgICAgIHJlZmVycmFsSWQgPSAoZGF0YSBhcyBhbnkpPy5pZCB8fCBudWxsXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEluc2VydCBjb252ZXJzaW9uXHJcbiAgICBjb25zdCB7IGVycm9yOiBjb252ZXJzaW9uRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdjb252ZXJzaW9ucycpXHJcbiAgICAgIC5pbnNlcnQoe1xyXG4gICAgICAgIGNsaWNrX2lkOiBwYXJhbXMuY2xpY2tJZCxcclxuICAgICAgICByZWZlcnJhbF9pZDogcmVmZXJyYWxJZCxcclxuICAgICAgICBhbWF6b25fdXJsOiBwYXJhbXMuYW1hem9uVXJsLFxyXG4gICAgICB9IGFzIGFueSlcclxuICAgIFxyXG4gICAgaWYgKGNvbnZlcnNpb25FcnJvcikgdGhyb3cgY29udmVyc2lvbkVycm9yXHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBjbGljayBhcyBjb252ZXJ0ZWQgaWYgY2xpY2tJZCBwcm92aWRlZFxyXG4gICAgaWYgKHBhcmFtcy5jbGlja0lkKSB7XHJcbiAgICAgIGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2NsaWNrcycpXHJcbiAgICAgICAgLnVwZGF0ZSh7IGNvbnZlcnRlZDogdHJ1ZSB9KVxyXG4gICAgICAgIC5lcSgnaWQnLCBwYXJhbXMuY2xpY2tJZClcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZXJyb3I6IG51bGwgfVxyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdHJhY2tpbmcgY29udmVyc2lvbjonLCBlcnIpXHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVyciBhcyBFcnJvciB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGNsaWVudCBJUCBhZGRyZXNzIChzZXJ2ZXItc2lkZSBvbmx5KVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENsaWVudElQKHJlcXVlc3Q6IFJlcXVlc3QpOiBzdHJpbmcgfCBudWxsIHtcclxuICAvLyBUcnkgdmFyaW91cyBoZWFkZXJzIChWZXJjZWwsIENsb3VkZmxhcmUsIGV0Yy4pXHJcbiAgY29uc3QgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVyc1xyXG4gIFxyXG4gIHJldHVybiAoXHJcbiAgICBoZWFkZXJzLmdldCgneC1yZWFsLWlwJykgfHxcclxuICAgIGhlYWRlcnMuZ2V0KCd4LWZvcndhcmRlZC1mb3InKT8uc3BsaXQoJywnKVswXSB8fFxyXG4gICAgaGVhZGVycy5nZXQoJ2NmLWNvbm5lY3RpbmctaXAnKSB8fFxyXG4gICAgbnVsbFxyXG4gIClcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3QgdHJhY2tpbmcgcGFyYW1ldGVycyBmcm9tIFVSTFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUcmFja2luZ1BhcmFtcyh1cmw6IHN0cmluZykge1xyXG4gIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKVxyXG4gIGNvbnN0IHBhcmFtcyA9IHVybE9iai5zZWFyY2hQYXJhbXNcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgcmVmZXJyYWxDb2RlOiBwYXJhbXMuZ2V0KCdyZWYnKSB8fCB1bmRlZmluZWQsXHJcbiAgICB1dG1Tb3VyY2U6IHBhcmFtcy5nZXQoJ3V0bV9zb3VyY2UnKSB8fCB1bmRlZmluZWQsXHJcbiAgICB1dG1NZWRpdW06IHBhcmFtcy5nZXQoJ3V0bV9tZWRpdW0nKSB8fCB1bmRlZmluZWQsXHJcbiAgICB1dG1DYW1wYWlnbjogcGFyYW1zLmdldCgndXRtX2NhbXBhaWduJykgfHwgdW5kZWZpbmVkLFxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJVQVBhcnNlciIsImdldERldmljZVR5cGUiLCJ1c2VyQWdlbnQiLCJwYXJzZXIiLCJkZXZpY2VUeXBlIiwiZ2V0RGV2aWNlIiwidHlwZSIsImhhc2hJUCIsImlwIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZGF0YSIsImVuY29kZSIsImhhc2hCdWZmZXIiLCJjcnlwdG8iLCJzdWJ0bGUiLCJkaWdlc3QiLCJoYXNoQXJyYXkiLCJBcnJheSIsImZyb20iLCJVaW50OEFycmF5IiwibWFwIiwiYiIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJqb2luIiwidHJhY2tDbGljayIsInBhcmFtcyIsImlwSGFzaCIsImlwQWRkcmVzcyIsInJlZmVycmFsSWQiLCJyZWZlcnJhbENvZGUiLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsImlkIiwiZXJyb3IiLCJpbnNlcnQiLCJyZWZlcnJhbF9pZCIsInV0bV9zb3VyY2UiLCJ1dG1Tb3VyY2UiLCJ1dG1fbWVkaXVtIiwidXRtTWVkaXVtIiwidXRtX2NhbXBhaWduIiwidXRtQ2FtcGFpZ24iLCJkZXZpY2VfdHlwZSIsImlwX2hhc2giLCJsYW5kaW5nX3BhZ2UiLCJsYW5kaW5nUGFnZSIsImNvbnZlcnRlZCIsImNsaWNrSWQiLCJlcnIiLCJjb25zb2xlIiwidHJhY2tDb252ZXJzaW9uIiwiY29udmVyc2lvbkVycm9yIiwiY2xpY2tfaWQiLCJhbWF6b25fdXJsIiwiYW1hem9uVXJsIiwidXBkYXRlIiwic3VjY2VzcyIsImdldENsaWVudElQIiwicmVxdWVzdCIsImhlYWRlcnMiLCJnZXQiLCJzcGxpdCIsImV4dHJhY3RUcmFja2luZ1BhcmFtcyIsInVybCIsInVybE9iaiIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/utils/tracking.ts\n"));

/***/ })

});